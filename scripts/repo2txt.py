#!/usr/bin/env python3
# This script dumps the contents of a Git repository into a single file.
# It's designed to make it easier to use repository content in RAG systems
# or as part of prompts for Large Language Models (LLMs).
# Copied from https://github.com/artkulak/repo2file
import os
import fnmatch
import argparse
from typing import List, Set, Optional, Tuple
from datetime import datetime, timezone

EXT_TO_LANG = {
    ".py": "python", ".js": "javascript", ".ts": "typescript", ".tsx": "typescript",
    ".html": "html", ".css": "css", ".md": "markdown", ".json": "json",
    ".yaml": "yaml", ".yml": "yaml", ".sh": "bash", ".cpp": "cpp", ".c": "c",
    ".java": "java", ".jsx": "javascript", ".go": "go", ".rs": "rust",
    ".kt": "kotlin", ".m": "objectivec", ".swift": "swift", ".rb": "ruby",
    ".php": "php", ".ps1": "powershell", ".sql": "sql", ".proto": "protobuf",
    ".toml": "toml", ".ini": "ini", ".xml": "xml", ".svg": "xml", ".tex": "latex",
}

SENSIBLE_DEFAULTS = {
    ".git/", "node_modules/", "dist/", "build/", ".venv/", "__pycache__/",
}


class RepoScanner:
    """
    A class to scan a repository, filter files, and dump the content to a single file
    in an LLM-optimized format.
    """

    def __init__(self, start_path: str, output_file: str, exclusion_file: Optional[str] = None, file_types: Optional[List[str]] = None, use_sensible_defaults: bool = False):
        self.start_path = os.path.abspath(start_path)
        self.output_file = output_file
        self.exclusion_file = exclusion_file
        self.file_types = file_types
        self.exclusion_patterns = self._parse_exclusion_file(use_sensible_defaults)

    def _parse_exclusion_file(self, use_sensible_defaults: bool) -> Set[str]:
        """
        Parses an exclusion file and adds sensible defaults if requested.
        """
        patterns = set()
        if use_sensible_defaults:
            patterns.update(SENSIBLE_DEFAULTS)

        if self.exclusion_file and os.path.exists(self.exclusion_file):
            with open(self.exclusion_file, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        patterns.add(line)
        return patterns

    def _is_excluded(self, path: str) -> bool:
        """
        Checks if a given path matches any of the exclusion patterns.
        """
        for pattern in self.exclusion_patterns:
            if fnmatch.fnmatch(path, pattern) or fnmatch.fnmatch(os.path.basename(path), pattern):
                return True
        return False

    def _get_language(self, file_path: str) -> str:
        """
        Infers the programming language from the file extension.
        """
        _, ext = os.path.splitext(file_path)
        return EXT_TO_LANG.get(ext, "text")

    def _read_file_content(self, path: str) -> Tuple[Optional[str], int, bool, int]:
        """
        Reads file content, detects if it's binary, and counts lines.
        Returns (content, line_count, is_binary, byte_len).
        """
        try:
            with open(path, "rb") as fb:
                data = fb.read()
            text = data.decode("utf-8")
            line_count = text.count("\n") + (1 if text and not text.endswith("\n") else 0)
            return text, line_count, False, len(data)
        except UnicodeDecodeError:
            return None, 0, True, len(data)

    def _generate_directory_structure(self) -> str:
        """
        Generates a string representation of the directory structure.
        """
        tree = ['/']

        def _generate_tree(dir_path: str, prefix: str = '') -> None:
            entries = sorted(os.listdir(dir_path), key=str.lower)

            for i, entry in enumerate(entries):
                rel_path = os.path.relpath(os.path.join(dir_path, entry), self.start_path)
                if self._is_excluded(rel_path):
                    continue

                full_path = os.path.join(dir_path, entry)
                connector = '└── ' if i == len(entries) - 1 else '├── '
                name = f"{entry}/" if os.path.isdir(full_path) else entry
                tree.append(f"{prefix}{connector}{name}")

                if os.path.isdir(full_path):
                    new_prefix = f"{prefix}{'    ' if i == len(entries) - 1 else '│   '}"
                    _generate_tree(full_path, new_prefix)

        _generate_tree(self.start_path)
        return '\n'.join(tree)

    def scan_and_dump(self) -> None:
        """
        Scans the repository and writes the directory structure and file contents to the output file.
        """
        with open(self.output_file, 'w', encoding='utf-8') as out_file:
            out_file.write("# Repository Overview\n")
            out_file.write(f"Path: {self.start_path}\n")
            out_file.write("Generated by repo2txt.py\n")
            out_file.write(f"Date: {datetime.now(timezone.utc).isoformat()}\n\n")
            out_file.write("## Directory Tree\n")
            out_file.write(self._generate_directory_structure())
            out_file.write("\n\n---\n\n")

            for root, dirs, files in os.walk(self.start_path, topdown=True):
                dirs.sort(key=str.lower)
                rel_path = os.path.relpath(root, self.start_path)
                if self._is_excluded(rel_path):
                    dirs[:] = []
                    files[:] = []
                    continue

                for file in sorted(files, key=str.lower):
                    raw_rel = file if rel_path == "." else os.path.join(rel_path, file)
                    file_rel_path = raw_rel.replace(os.sep, "/")

                    if self._is_excluded(file_rel_path):
                        continue

                    if not self.file_types or any(file.endswith(ext) for ext in self.file_types):
                        file_path = os.path.join(root, file)
                        content, line_count, is_binary, byte_len = self._read_file_content(file_path)

                        out_file.write(f"# FILE: {file_rel_path}\n")
                        if is_binary:
                            out_file.write(f"LANG: binary\nSIZE: {byte_len} bytes\n\n")
                            out_file.write("# BINARY FILE (skipped)\n")
                        else:
                            lang = self._get_language(file_path)
                            out_file.write(f"LANG: {lang}\nSIZE: {line_count} lines\n\n")
                            fence = "````" if "```" in content else "```"
                            out_file.write(f"{fence}{lang}\n{content}\n{fence}\n")

                        out_file.write("\n# END FILE\n\n---\n\n")


def main() -> None:
    """
    Main function to parse arguments and run the repository scanner.
    """
    parser = argparse.ArgumentParser(
        description='Scan a folder and write the contents to an LLM-optimized output file.',
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument('start_path', type=str, help='The path to the folder to scan.')
    parser.add_argument('output_file', type=str, help='The path to the output file.')
    parser.add_argument('-e', '--exclusion-file', type=str, help='Path to a .gitignore-style exclusion file.')
    parser.add_argument('-t', '--file-types', type=str, nargs='*', help='File extensions to include.')
    parser.add_argument('--sensible-defaults', action='store_true', help='Exclude common noise like .git, node_modules.')
    args = parser.parse_args()

    scanner = RepoScanner(
        start_path=args.start_path,
        output_file=args.output_file,
        exclusion_file=args.exclusion_file,
        file_types=args.file_types,
        use_sensible_defaults=args.sensible_defaults
    )

    print(f"Starting scan of '{args.start_path}'...")
    scanner.scan_and_dump()
    print(f"Scan complete. Results written to '{args.output_file}'")


if __name__ == "__main__":
    main()
